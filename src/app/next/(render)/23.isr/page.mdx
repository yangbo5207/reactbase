import {CodeTabs} from '@/components/code-with-tabs'

## Table of contents

## 背景

SSR(动态服务端渲染) 在实现逻辑上相对来说是比较简单，并且容易理解，但是在用户规模上来之后，对服务端的内容与并发压力对于开发者来说，是一个巨大的挑战。此时网站访问速度会变得非常缓慢，甚至直接崩溃。

为了应对这种**并发压力**，NextJS 中提出了许多有效的技术架构方案，其中包括

+ 1、**SSG** 静态渲染
+ 2、**ISR** 静态增量渲染
+ 3、**PPR** 部分静态渲染
+ 4、**ESR** 边缘动态渲染

> 在过往的一些方案中，有的团队提出了一种**优雅降级**的策略来解决内存不足的问题。优雅降级指的是当访问量过大时，通过一些技术手段（例如 监听内存使用情况）

最理想的情况就是使用 SSG，在我们执行 `next build` 时，就可以将需要的页面全部渲染好，服务端不需要参与额外的逻辑执行就能把页面返回给客户端。但是许多情况下，我们无法提前预判所有的渲染内容。因此，在真实场景中，SSG 的应用场景十分有限，它仅仅适用部署上线之后，页面内容都基本上固定不改变的情况。

因此，我们在学习后续的方案时，首先需要明确，**动态渲染无法完全消除，只能我们根据实际情况进行削弱**。

**ISR** 就是在此基础之上，针对其中一种场景，提出的削弱动态渲染的方案。



## ISR 适用场景

假如我们正在开发一个博客系统。当我们将其中一篇博文发布之后，在后续的过程中，我们可能还需要对该文章进行修改。大多数情况下，文章内容是不会被改变的。因此，针对这种情况，我们首先会考虑是否需要选择静态渲染。

但问题是，在少数情况下文章内容需要更新，例如作者需要修改文章内容。此时如果选择静态更新的话，那么每一次更新内容就必须要重新 `build`。很明显这是不合适的，一方面是 build 的时间可能会比较长，无法做到即时更新，另外一方面是还需要重新部署，肯定也不合理。

但是如果我们使用 SSR 动态渲染的话，在绝大多数情况下，文章内容又是不变的，因此一定会存在大量的重复工作。这是完全没有必要的负担。

在这种情况之下，NextJS 提出了一个折中的解决方案，**静态增量更新**：ISR。

ISR 指的是，我们可以缓存构建结果，在合适的时间点，在不需要重新部署的情况下，重置缓存，自动在后台重新构建对应的单个页面，而不是重新构建整个项目。

在 Next 中，要使用 ISR 比较容易，我们只需要通过配置让缓存生效，然后再合适的时候让缓存失效就行，Next 提供了比较方便的方式来做到这个事情。


## revalidate

我们可以在 `layout.tsx` 或者 `page.tsx` 中配置 `revalidate` 来设置页面缓存方式。

```tsx page.tsx/layout.tsx
export const revalidate = false
// false | 0 | number
```

**false**

表示持久缓存。页面的最终缓存方式，会结合该配置与在页面中的 `fetch` 方法配置共同生效。如果 `fetch` 方法的配置为 `force-cache`，并且对应路由中没有使用动态 API，那么就会持久缓存。

如果我们希望部分页面不缓存，那么，可以设置 fetch 的 `cache: 'no-store'` 或者 `revalidate: 0` 来做到。

```ts
fetch(`https://...`, { cache: 'no-store' })
```

**number: 0**

不缓存。表示页面始终是动态渲染。即使未使用动态 API。但当 fetch 的配置为 `force-cache` 时，会缓存数据。

```ts
fetch(`https://...`, { cache: 'force-cache' })
```

**number**

其他数值，表示每隔多少秒缓存会重置。如果同一路由中，有多个 `revalidate` 非 0 数值，那么将会是数值最小的那一个最终生效。

注意，在如下几种情况，`revalidate` 的配置是无效的

**1、** 运算值无效，直接值有效

```ts page.tsx
// !diff -
export const revalidate = 60 * 10 // 无效

// !diff +
export const revalidate = 600 // 有效
```

**2、** 运行时为 `edge` 时无效 _`runtime = 'edge'`_

```ts page.tsx
export const runtime = 'edge'
// 'nodejs' | 'edge'
```

**3、** 在开发模式中无效，开发模式中，始终按照动态渲染呈现结果。

// 待续...
