import {CodeTabs} from "@/components/code-with-tabs";

## Table of contents

## 问题

在现如今的前端网站中，支持暗黑模式是一个基本的功能，正如本网站一样。但是要在服务端渲染的项目中比较完美的支持暗黑模式，则面临许多麻烦。这里最主要的一个麻烦就是，假如我们的网页默认支持的是 `light` 模式，但是当我切换到 `dark` 模式之后，第二次再访问时，我希望该页面依然是 `dark mode`。

那么我们就必须要做的一个事情就是，在页面渲染的第一时间，就能够得知，该页面就是 `dark mode`。

我们面临的一个比较难结局的问题就是，该状态应该存储在哪里？

## 数据来源

当我们第二次访问时，我们有两个数据来源。

第一种，将该状态存储在直接存在服务端。这样，我们可以在服务端把对应的状态 class 渲染到页面上，直接直出 `dark mode`。

但是这种方案有一个问题就是，如果我们要在服务端区分清楚不同用户的状态，存的时候就必须按用户来存。因此第二次访问时，为了得到这个状态，我们首先要做用户的鉴权，鉴权失败就得不到状态。这里存在两个不良影响。

一是健全失败之后，无法获得 `dark mode`，只能显示默认的 `light mode`。

二是后端逻辑链路偏长，要先鉴权，然后访问用户信息，从用户信息中获取用户的存储状态，可能会导致页面直出速度不够快。

第二种，将该状态直接缓存在 `localStorage` 中。通过客户端组件的逻辑去设置 `dark mode`。

但是这种方案如果不仔细处理，也会存在问题，我们在了解了执行常规顺序之后，再来分析这种方案的问题在哪里


## 执行顺序

在 Next.js 的项目中，当我们首次访问页面时，会首先执行服务端组件的渲染。向客户端返回字符串。

然后客户端得到字符串之后，浏览器会渲染该字符串，此时渲染完成之后就会直接显示页面。此时的问题就在于，我们准备的 `dark mode` 的逻辑还没有执行，因此页面会首先显示 `light mode`.

然后进行 React 组件的水合，在水合的过程中执行客户端组件，这个过程中会执行从 `localStorage` 中获取上次访问时设置的 `dark mode`，水合渲染完成之后，显示 `dark mode`

所以最终的效果是，页面初始化的过程会经历一个先显示 `light mode` ，然后显示 `dark mode` 的切换过程。

这并不符合我们的期望。

我们期望的是，页面刷新时，就直接是 `dark mode`，而不是经历闪一下切换的过程。

于是，要解决这个问题，就变成了一个很难搞定的点。

那应该怎么办呢？我们在后续的逻辑中，一点点的来剖析这个方案。
