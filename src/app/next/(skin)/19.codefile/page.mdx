import {CodeTabs} from "@/components/code-with-tabs";

## Table of contents

## 实现 dark mode

掌握了上一章的基础知识，我们可以很容易实现 `dark mode`

首先，由于是针对全网站的样式切换，因此，我们需要在最顶层的 `html` 标签上进行 css 规则作用域的切换

```html
<html class='dark'>
  ...
</html>
```

相应的 css 变量定义为如下

```css
:root {
  --background: 0 0% 100%;
  --foreground: 240 10% 3.9%;
  ...
}
.dark {
  --background: 240 10% 3.9%;
  --foreground: 0 0% 98%;
  ...
}
```

默认情况使用定义在 `:root` 中的值。`dark mode` 下使用 `.dark` 中定义的值。

我们只需要确保后续的所有颜色相关的样式，都使用这些自定义变量。然后，当我们通过操作 `html` 的 classList，删除或者新增 `.dark`，就可以做到普通模式和暗黑模式的切换。

## 如何更新 html class

在根 `Layout.tsx` 中，我们可以使用 `useState` 的方式更新 html 中的 class

```tsx
'use client';

import {useState} from 'react'
export default async function RootLayout({ children }) {
  const [theme, setTheme] = useState('light')
  return (
    <html lang="zh" suppressHydrationWarning className={`bg-background ${theme}`}>
      <body className='text-sm text-foreground h-full'>
        ...
        {children}
      </body>
    </html>
  )
}
```

但是这样更改的话，我们就直接在根节点就必须使用 `use client`，这就会导致整个项目都变成了客户端渲染。因此我们不能这样处理。

除此之外，整个项目中，还有别的地方需要使用 `theme` 的状态，例如切换按钮时。因此，我们也应该将该状态存储在 `context` 中

那么我们应该按照前面说过的 RSC 代码组织的规范，我们需要对代码进行重新整理，理想的效果如下

```ts
// 注意，这里指的是模块结构树. 该模块结构树，由 import 引入组成
//  + 表示还有子节点，- 表示叶子节点
+ Layout.tsx
  - context.tsx // 此时 context 是树形结构中的叶子结点
  + page.tsx
    + component1.tsx
    + component2.tsx
    + ...
```

这里需要特别注意的是，模块结构树，是由模块之间使用 `import` 引入别的模块组成。它**不是文件结构树**。也**不是 Fiber tree**，不是父子组件之间的关系。

因此，在 `Layout.tsx` 中，我们的代码大概如下

```js
import './globals.css'
import {ThemeProvider} from '@/components/switch-themes'

export const metadata = {
  title: '这波能反杀的付费课',
  description: 'Generated by Next.js',
}

export default async function RootLayout({ children }: any) {
  return (
    <html lang="zh" suppressHydrationWarning className='bg-background h-full'>
      <body className='text-sm text-foreground h-full'>
        <ThemeProvider defaultTheme='light'>
          {children}
        </ThemeProvider>
      </body>
    </html>
  )
}
```

此时，我们创建了 `ThemeProvider`，并且使用 `import` 引入。所以这个时候，一定要识别清楚，此时的 `ThemeProvider` 在组件结构树中，是叶子节点。因此，我们可以直接将其标记为 `use client`，而不需要担心他影响到后续的组件模块

```js
'use client'

import {createContext, useState} from 'react'

export const ThemeContext = createContext(null)
const themes = ['light', 'dark']

export default function Provider(props: ThemeProviderProps) {
  const {children, defaultTheme, storageKey = 'theme', ...other} = props
  const [theme, changeTheme] = useState(() => getTheme(storageKey, 'light'))

  const value = {...}

  return (
    <ThemeContext value={value}>
      {children}
    </ThemeContext>
  )
}
```

ok，当我们这样组织了代码之后，此时又无法直接使用 `use` 获取状态来设置 `html` 的 class 了。因此，我们需要考虑另外的办法来更新它。当然，这个办法也很简单，如下所示

```js
'use client'

import {createContext, useState, useEffect} from 'react'

export const ThemeContext = createContext(null)
const themes = ['light', 'dark']

export default function Provider(props: ThemeProviderProps) {
  const {children, defaultTheme, storageKey = 'theme', ...other} = props
  const [theme, changeTheme] = useState(() => getTheme(storageKey, 'light'))

  // !diff +
  useEffect(() => {
    // !diff +
    const d = document.documentElement
    // !diff +
    d.classList.add(theme)
    // !diff +
  }, [theme]);

  const value = {...}

  return (
    <ThemeContext value={value}>
      {children}
    </ThemeContext>
  )
}
```

## 文件结构与模块结构

这里我们一定要特别注意把代码结构与模块结构区分开。前面虽然我们已经强调过，但是由于非常容易引起误解，因此我这里还需要赘述一下。

模块结构是由模块之间 `import` 引入组成。我们在 RSC 中，`use client` 前缀分割的是模块结构。当前模块之后的所有模块都会自动被解析为客户端组件。因此，我们最好的方式就是把叶子节点设计为客户端组件。例如此时的 `ThemeContext`

在 NextJS 中，只有路由相关的知识点需要特别关注文件结构。在 `src/app` 中，文件结构需要按照约定式路由按照所见即所得的标准组织。

