## Table of contents

## 什么是同构

服务端渲染，server side rendering，在日常工作中，被我们俗称为 SSR. 这是一种将页面拼接的工作放到服务端的渲染方案。ssr 主要是针对动态内容的页面提出的一种解决方案。

这里解释一下什么是**动态内容页面**。例如同样一个页面路由 `user/information`，此时对于不同的用户而言，他们虽然访问的都是同一个地址，但是访问之后，看到的信息内容却不一样。正因为是不同的用户，因此，当用户访问到该页面时，我们要做的事情是：根据不同的用户身份，从数据库拿到不同的信息，然后把这个信息与开发者提前准备好的模板渲染到一起，最后得到完整的页面内容，再给用户展示。

如果我们把这一段逻辑，在客户端呈现，实现的思路大概如下

首先，我们会有一个接口函数，用于向服务端请求数据

```ts
function getUserInfo() {
  return axios.get('user/info')
}
```

然后在组件首次渲染完成之后发起请求，请求成功之后，将数据传入提前准备好的 `Userinfo` 组件渲染出最终的显示结果。

```tsx Userinfo.client.tsx
function Userinfo() {
  const [userinfo, setUserinfo] = useState<Userinfo>({})

  useEffect(() => {
    getUserInfo().then(res => setUserinfo(res.data))
  }, [])

  if(Userinfo.id) {
    // 在数据还没有请求成功时，使用 Loading 组件占位
    return <Loading />
  }

  return (
    <Userinfo userinfo={userinfo} />
  )
}
```

这里我们需要思考的一个问题，是在客户端渲染中，为什么需要在组件首次渲染完成之后，再去发送请求，而不是直接发请求，请求成功之后，再渲染页面？按照这个思路，我们的代码可以演变成如下这个样子。代码会简洁非常多。

```tsx Userinfo.tsx
async function Userinfo() {
  const res = await getUserInfo()

  return (
    <Userinfo userinfo={res.data} />
  )
}
```

可能有的人认为是为了快速响应，不白屏，其实只有一部分原因是因为这个。例如，你的接口是 100ms 请求成功，那么不用 Loading 你的白屏时间也只有 100ms，这么短时间的白屏并不会对用户体验造成太大的影响。但是长时间的 Loading 一样会代码非常不好的用户体验。Loading 的作用更多的是为了提示用户页面正在加载数据。

实际上，最主要的原因是因为，我们在**客户端渲染**的组件，除了要考虑初始化的逻辑之外，还需要额外考虑**更新的逻辑**。如果要考虑更新逻辑，我们就不得不借助 `useEffect` 来执行一部分逻辑。


但是，在服务端渲染的逻辑中，由于服务端渲染的最终产物只是**字符串**，因此，我们不必在服务端渲染的组件考虑更新的逻辑，因此在服务端，我们就可以非常轻松的把代码写成如下的模样。

```tsx Userinfo.server.tsx
async function Userinfo() {
  const res = await getUserInfo()

  return (
    <Userinfo userinfo={res.data} />
  )
}
```

## ssr 大概流程

理解了前面关于动态页面的基本概念，以及在服务端的处理方案，我们需要进一步理解一下整个逻辑的执行过程。

大概流程以此如下所示

1、客户端访问 url，向服务端发起请求

2、服务端接收到请求之后，根据路由执行不同的页面组件

3、页面组件的执行过程中，会向其他服务端或者数据库请求数据，请求成功之后再与模板渲染成**字符串**

4、页面组件执行完毕，得到页面内容，向客户端返回该内容

5、客户端得到内容之后，由浏览器渲染页面，这样可以做到**页面直出**


在这个流程中，我们可以发现，**动态数据的获取可以直接前置到浏览器渲染之前**。因此在这种情况之下，我们不仅可以做到页面直出，页面内容对于搜索引擎的 SEO 也非常友好。这是我们做服务端渲染的两个核心刚需。在海外，谷歌 SEO 对网站的流量起着至关重要的作用。

## ssr 面临的挑战

ssr 看上去一切都很美好。但在实践过程中，会面临非常具体的困境。

每一个动态内容页面有一个具体的工作要做，那就是**请求数据、并将数据与模板渲染成完整的页面内容**。在 ssr 中，这个工作是在服务端来完成。在 csr (客户端渲染)中，这个工作在客户端来完成。这个差别所带来的一个巨大的影响就是，当用户访问规模上来之后，服务端可能会承受巨大的压力。

例如你的网站页面日活是 1000 万，页面请求并发量在 10 万左右。ssr 虽然能够将渲染逻辑前置带来 SEO 的便利，但是同时，他也把 10 万并发量的工作压力带到了服务端。这个时候，服务器的执行效率就会大大降低，可能会导致大量的页面需要花费 10s 以上才能显示出内容。

而客户端把渲染工作分散到 10 万个用户设备上，于是在服务端这一侧，压力要低很多很多。

因此，ssr 面临的挑战是，当你的网站做得很好，用户量规模变大，并发压力上来之后，如果解决好页面的初始访问时间？

对于前端开发来说，这是一个非常难解决的问题。许多初级前端因为连 ssr 的需求都没有接触过，所以对此感受很微弱，但是要知道，国内有许多团队在这上面都束手无策。

我之所以要把 Next.js 定性为突破高级程序员的关键技术栈，就是因为 Next.js 直面服务端的并发问题，针对这个挑战提供了一整套的解决方案。在后面我们会详细为大家分析。
